Guide pédagogique : Suivre les coûts GCP et l’empreinte carbone avec une appli Next.js (FinOps & GreenOps)
1. Configuration côté client (projet GCP du client)
Pour que votre application SaaS puisse accéder aux données de coûts cloud et d’empreinte carbone des projets GCP de vos clients, certaines configurations sont nécessaires sur l’environnement Google Cloud de chaque client.
1.1 Activation des APIs Google Cloud requises
Assurez-vous d’activer les APIs suivantes sur le projet Google Cloud du client et/ou sur le projet GCP hébergeant votre application SaaS (voir remarque sur l’authentification en section 2) :
	•	Cloud Billing API (cloudbilling.googleapis.com) – Permet de lister les comptes de facturation et les projets associés, et de lier des projets à un compte de facturation[1]. Lien d’activation : Cloud Billing API – Google Cloud Console.
	•	Cloud Billing Budget API (billingbudgets.googleapis.com) – Permet de créer et consulter des budgets de dépenses et leurs alertes. Lien d’activation : Cloud Billing Budget API – Google Cloud Console.
	•	BigQuery Data Transfer Service API (bigquerydatatransfer.googleapis.com) – Nécessaire si l’on choisit d’exporter l’empreinte carbone vers BigQuery (voir section 2.2.3). Cette API permet de configurer par programmation le transfert des données d’empreinte carbone vers un dataset BigQuery[2].
	•	BigQuery API (bigquery.googleapis.com) – Permet de requêter les datasets BigQuery (pour récupérer les coûts détaillés et les données carbone exportées). À activer sur le projet où sont stockées ces données (souvent un projet GCP du client).
Remarque : L’activation d’une API se fait typiquement côté projet SaaS si vous utilisez l’authentification utilisateur OAuth (c’est le projet associé à vos identifiants OAuth qui consommera l’API). Cependant, dans certains cas, le projet du client doit aussi activer l’API (par ex. si vous utilisez un compte de service du client). En cas de doute, il est conseillé d’activer les APIs sur le projet du client et sur le projet intégrateur.
1.2 Rôles IAM à attribuer
Pour permettre à votre application d’accéder aux données de facturation et de carbone, le client doit vous accorder certains rôles IAM (ou les avoir lui-même s’il s’authentifie via OAuth) :
	•	Sur le compte de facturation GCP du client : le rôle “Billing Account Viewer” (roles/billing.viewer) est recommandé. Ce rôle permet de consulter les informations de facturation, y compris les coûts du compte et les budgets[3]. Il inclut également la permission de lecture des données d’empreinte carbone du compte de facturation (billing.accounts.getCarbonInformation)[4][5]. Ce rôle sera suffisant pour la plupart des besoins en lecture (FinOps et GreenOps). Si l’application doit créer/modifier des budgets via l’API, il faudra un rôle plus élevé comme “Billing Account Costs Manager” (roles/billing.costsManager) ou “Billing Account Admin”. Pour simplement lire les budgets existants, billing.viewer suffit car il inclut billing.budgets.get et billing.budgets.list[6][7].
	•	Sur le(s) projet(s) GCP du client : un rôle “Project Viewer” ou “Project Owner” sur chaque projet concerné est recommandé, afin de permettre la lecture des informations du projet (notamment utile pour lister les projets et vérifier qu’ils sont bien rattachés à un compte de facturation). Pour l’export BigQuery, le rôle “BigQuery Data Viewer” sur le dataset d’export peut être nécessaire si votre application interroge directement le dataset de facturation ou d’empreinte carbone. (Ce point est détaillé section 2.2.3.)
	•	Pour lier un projet à un compte de facturation : le client (ou le compte de service) doit posséder le rôle “Billing Account User” (roles/billing.user) sur le compte de facturation et être Owner/éditeur du projet en question[8][9]. Ce combo de permissions est requis pour associer un projet à un compte de facturation.
En résumé, demandez à votre client de vous donner au minimum le rôle Lecteur du compte de facturation sur son compte de facturation GCP, ainsi qu’un rôle en lecture sur les projets à analyser. Ces rôles peuvent être octroyés à un compte de service (si vous optez pour une auth serveur à serveur) ou au compte utilisateur qui réalisera l’OAuth (si vous optez pour OAuth2 utilisateur).
1.3 Association d’un projet GCP à un compte de facturation
Chaque projet GCP doit être rattaché à un compte de facturation valide pour générer des coûts (et donc des données FinOps/GreenOps). Sans compte de facturation, un projet restera en mode gratuit/sandbox et ne produira pas de coûts facturables.
Comment lier un projet à un compte de facturation :
	•	Dans la console Google Cloud, accédez à la page « Gestion des comptes de facturation » (menu Facturation).
	•	Allez dans l’onglet « Mes projets » pour voir la liste des projets et leur compte de facturation associé.
	•	Repérez le projet client à lier : s’il indique « Facturation désactivée » dans la colonne Compte de facturation, cliquez sur le menu Actions (⋮) à droite de ce projet, puis choisissez « Modifier la facturation ».
	•	Sélectionnez le compte de facturation du client à associer à ce projet, puis validez (bouton « Définir le compte »).
Une fois cette opération effectuée, le projet est lié au compte de facturation du client ; tous les coûts générés par ce projet seront imputés à ce compte. Il est conseillé de vérifier dans le même écran que le projet apparaît bien sous le bon compte de facturation (et éventuellement verrouiller ce lien pour éviter toute modification involontaire). (Nécessite des permissions adéquates comme mentionné plus haut : Project Owner + Billing Account User.)
1.4 Limitations et conditions importantes côté GCP
	•	Compte de facturation actif : le compte de facturation du client doit être actif et en règle. Si le compte est fermé ou suspendu, aucun coût ni export ne sera disponible et les APIs de facturation n’afficheront rien d’utile. Assurez-vous que le compte n’est pas suspendu pour dépassement ou autre problème.
	•	Budgets sur le compte de facturation : pour utiliser l’API Budget, le compte de facturation du client doit être associé à un projet Google Cloud où l’API Budget est activée (cf. 1.1). Souvent, on utilise un projet “financier” dédié du client pour gérer budgets et exports. Sans cela, les appels API Budget peuvent être refusés. De plus, n’oubliez pas qu’un budget est défini par compte de facturation : le client devra donc avoir créé au moins un budget sur son compte (via la console ou l’API) s’il veut que votre appli en récupère les données d’alerte.
	•	Exports BigQuery : les données de coûts détaillés et d’empreinte carbone ne sont disponibles que via export BigQuery. Il faut donc configurer ces exports au préalable. L’export de facturation vers BigQuery (coûts) se fait dans la section Facturation > Export dans BigQuery du compte de facturation (quotidiennement, avec un historique commençant à partir de la date d’activation). L’export de l’empreinte carbone se fait via l’outil Carbon Footprint (voir 2.2.3) et ne remonte pas avant 2021 (les données carbone ne sont disponibles qu’à partir de Janvier 2021)[10]. De plus, cet export carbone est mensuel (les données de chaque mois M sont disponibles vers le 15 du mois M+1)[11]. Important : si l’export BigQuery n’est pas configuré, il n’existe aucune API REST pour obtenir le détail des coûts passés ou l’empreinte carbone du projet : la console GCP affiche ces infos, mais Google ne fournit pas d’endpoint public pour les récupérer directement[12]. On doit donc impérativement passer par BigQuery.
	•	Quotas d’API : les APIs Cloud Billing et Budget ont des quotas (nombre de requêtes par minute, etc.) mais ceux-ci sont généralement généreux pour une utilisation raisonnable. Par exemple, la liste des projets par compte de facturation est limitée à 100 projets par requête (pagination)[13]. Si un client a de très nombreux projets, vous devrez gérer la pagination (nextPageToken). Vérifiez également les quotas de l’API BigQuery si vous lancez des requêtes lourdes. En cas de dépassement de quota, votre application devra peut-être utiliser un mécanisme de cache ou de backoff exponentiel.
Maintenant que le client a configuré son GCP correctement (APIs activées, projets liés à la facturation, rôles attribués, exports en place), passons au côté intégration SaaS.
2. Développement côté SaaS intégrateur (Next.js)
Dans votre application Next.js hébergée sur Vercel (ou autre), vous allez implémenter :
	•	L’authentification OAuth2 permettant au client de consentir à l’accès à ses données GCP (facturation et carbone).
	•	Les appels aux APIs REST GCP pour récupérer les données FinOps/GreenOps du client.
	•	Le traitement des réponses JSON et l’affichage dans des tableaux de bord simples.
Tout cela en gardant à l’esprit que l’application sera potentiellement multi-client (chaque client autorisera l’accès à ses propres données).
2.1 Gestion de l’authentification OAuth2 vers Google Cloud
La première étape consiste à mettre en place l’authentification OAuth2 afin d’accéder aux APIs Google Cloud au nom du client. Voici un plan simple :
	•	Créer un client OAuth dans la Google Cloud Console (ou Google API Console) pour votre application SaaS. Choisissez “Application web” comme type d’application, et configurez le consent screen OAuth pour qu’il affiche clairement les accès demandés (par ex. « Accéder aux données de facturation de votre compte Google Cloud »). Ajoutez les URI de redirection nécessaires (par ex. l’URL de callback de votre appli Next.js).
	•	Scopes à demander : Lors de la redirection vers Google OAuth, spécifiez les scopes dont vous avez besoin. Pour lire les coûts et budgets, utilisez le scope Cloud Billing en lecture seule : https://www.googleapis.com/auth/cloud-billing.readonly. Ce scope permet de lire les comptes de facturation, projets et budgets (il englobe aussi cloud-billing de manière non restrictive, mais en lecture seule)[14]. Pour interroger BigQuery, ajoutez le scope BigQuery approprié (par exemple https://www.googleapis.com/auth/bigquery.readonly pour lire les données BigQuery). Vous pouvez à la place utiliser le scope très large cloud-platform qui donne accès à toutes les APIs Google Cloud en lecture/écriture[14], mais il est préférable de limiter aux scopes nécessaires pour réduire l’ampleur des permissions.
	•	Consentement utilisateur : Lorsqu’un client s’inscrit sur votre SaaS, il cliquera sur “Connecter mon compte Google Cloud”. Vous le redirigez vers l’URL OAuth de Google (accounts.google.com/o/oauth2/v2/auth) avec les scopes ci-dessus. Google affichera une page de consentement indiquant que votre application demande l’accès à “Gérer la facturation sur Google Cloud” (pour le scope cloud-billing) et l’accès BigQuery, etc. Le client devra accepter.
	•	Récupération du token : Après consentement, Google redirige vers votre URL de callback avec un code d’autorisation. Votre backend Next.js va échanger ce code contre un jeton d’accès OAuth2 (et un jeton de rafraîchissement si vous avez demandé access_type=offline). Vous obtenez ainsi un access_token utilisable pour appeler les APIs REST de Google Cloud au nom du client.
	•	Stockage sécurisé : Conservez le refresh_token de façon sécurisée (en base de données chiffrée par exemple) pour pouvoir régénérer des access_tokens sans repasser par le consentement. Le access_token a une durée de vie (généralement 1h). Vous pouvez stocker le token en session côté serveur ou utiliser une solution comme NextAuth.js qui gère automatiquement le refresh.
	•	OAuth via Next.js : Vous pouvez implémenter manuellement le flow OAuth ou utiliser une bibliothèque. Par exemple, la librairie NextAuth.js propose un provider Google configurable où vous pouvez spécifier des scopes custom. Veillez dans ce cas à bien ajouter les scopes cloud-billing et bigquery dans la configuration du provider Google. NextAuth gérera les callbacks et la persistance du token pour vous. Sinon, vous pouvez créer une route API Next.js /api/callback qui gère l’échange de code contre token en appelant l’endpoint Google Token (https://oauth2.googleapis.com/token). Dans tous les cas, à la fin, vous avez en main un token valable pour appeler les services Google Cloud autorisés.
	•	Project/quota association (header x-goog-user-project) : Google exige souvent qu’un “projet” soit imputé pour les appels aux APIs Cloud effectués avec un compte utilisateur. Cela sert à la facturation éventuelle des appels d’API. Pour cela, il est courant d’envoyer un en-tête x-goog-user-project dans vos requêtes API, contenant l’ID de votre projet GCP intégrateur. Ce projet doit avoir les APIs activées et la facturation active (cf. section 1.1). Dans les exemples ci-dessous, nous inclurons cet header si nécessaire. (S’il n’est pas fourni, certaines APIs comme Cloud Billing Budget API peuvent refuser les appels avec une erreur invitant à spécifier un project for billing.)
Enfin, notez que si votre application SaaS doit être multi-cloud (migrable sur AWS plus tard), essayez d’abstraire la logique d’authentification pour pouvoir y intégrer demain un OAuth vers AWS ou une autre méthode. Pour Google, nous avons maintenant un jeton prêt à être utilisé.
2.2 Appels aux APIs REST GCP pour FinOps & GreenOps
Avec le token d’accès OAuth2 du client, vous pouvez appeler les APIs REST Google Cloud nécessaires. Nous détaillons ci-dessous comment obtenir : (a) les comptes de facturation et projets, (b) les budgets et alertes, (c) les données d’empreinte carbone. Nous fournirons des exemples de requêtes HTTP en utilisant fetch (côté Node.js) ou Axios, ainsi que le format des réponses JSON.
2.2.1 Récupérer les comptes de facturation et projets (Cloud Billing API)
La Cloud Billing API permet de gérer et consulter les comptes de facturation. Dans notre cas d’usage, on l’utilisera surtout pour lister le(s) compte(s) de facturation du client et les projets associés à chaque compte.
	•	Lister les comptes de facturation : l’endpoint est GET https://cloudbilling.googleapis.com/v1/billingAccounts. Avec le bon jeton d’accès, cela renverra la liste des comptes de facturation auxquels l’utilisateur a accès. La réponse JSON contiendra un tableau billingAccounts avec, pour chaque compte, son name (ID au format billingAccounts/XXXX-XXXX-XXXX) et son displayName (souvent le nom attribué, par ex. « Mon Compte de Facturation »). Remarque : un utilisateur peut avoir plusieurs comptes (dans le cas où il gère plusieurs entités ou environnements).
	•	Exemple (en supposant que vous avez stocké le token dans une variable accessToken) :
	•	const res = await fetch(  "https://cloudbilling.googleapis.com/v1/billingAccounts",  {    headers: {       "Authorization": `Bearer ${accessToken}`,      "x-goog-user-project": "<ID-projet-integrateur>"     }  });const data = await res.json();console.log(data.billingAccounts);/* Sortie possible:data.billingAccounts = [  {     name: "billingAccounts/012345-67890-ABCDEF",     displayName: "Compte Facturation Principal",     open: true   }]*/
	•	Dans cet exemple, on obtient un seul compte (open=true signifie qu’il est actif). Vous pouvez extraire l’ID du compte à partir du champ name (dans l’exemple, l’ID est 012345-67890-ABCDEF).
	•	Lister les projets liés à un compte de facturation : une fois l’ID du compte obtenu, on peut interroger l’endpoint GET https://cloudbilling.googleapis.com/v1/billingAccounts/ID/projects (en remplaçant ID par l’identifiant du compte de facturation, par ex. 012345-67890-ABCDEF). Cet appel nécessite la permission billing.resourceAssociations.list (fournie par Billing Account Viewer comme vu plus haut)[1]. La réponse JSON contiendra un tableau projectBillingInfo. Chaque entrée contient typiquement :
	•	projectId : l’ID du projet GCP.
	•	billingAccountName : le nom du compte de facturation associé (identique à celui que vous avez interrogé).
	•	billingEnabled : un booléen indiquant si la facturation est activée sur le projet.
	•	Exemple :
	•	const billingAccountId = "012345-67890-ABCDEF";const res = await fetch(  `https://cloudbilling.googleapis.com/v1/billingAccounts/${billingAccountId}/projects`,  {    headers: {      "Authorization": `Bearer ${accessToken}`,      "x-goog-user-project": "<ID-projet-integrateur>"    }  });const data = await res.json();data.projectBillingInfo.forEach(proj => {  console.log(`${proj.projectId} -> billingEnabled = ${proj.billingEnabled}`);});/* Sortie console:   my-gcp-project-1  -> billingEnabled = true   my-gcp-project-2  -> billingEnabled = true   test-project      -> billingEnabled = false  (facturation désactivée)*/
	•	Ici, on liste tous les projets rattachés au compte de facturation du client. Dans l’exemple, test-project a billingEnabled=false, ce qui signifie que bien qu’il ait pu être associé auparavant, la facturation est actuellement coupée (ou le projet est verrouillé sur un autre compte). Vous pouvez filtrer ceux qui sont actifs. Notez que l’API ne fournit pas directement le nom lisible du projet ni d’autres détails – juste l’ID. Si vous avez besoin du nom complet ou d’informations supplémentaires, vous devrez appeler l’API Resource Manager (cloudresourcemanager.googleapis.com) pour obtenir des métadonnées du projet, mais ce n’est pas indispensable pour notre objectif de coûts.
	•	Vérifier qu’un projet est bien facturé : si nécessaire, vous pouvez appeler GET https://cloudbilling.googleapis.com/v1/projects/{projectId}/billingInfo pour un projet spécifique. Cela retourne un objet ProjectBillingInfo similaire aux éléments ci-dessus, confirmant à quel compte de facturation le projet est lié et s’il est actif. Par exemple, pour “my-gcp-project-1” : on interrogerait .../v1/projects/my-gcp-project-1/billingInfo. Ce n’est utile que si vous voulez vérifier un projet en particulier (la méthode bulk via le compte de facturation est en général suffisante).
En résumé, la Cloud Billing API nous permet d’obtenir la cartographie compte de facturation -> projets. Cela sert à afficher, par exemple, dans votre appli une liste déroulante si le client a plusieurs comptes, ou tout simplement à s’assurer quels projets du client seront pris en compte dans les calculs de coût.
2.2.2 Récupérer les budgets et alertes (Cloud Billing Budgets API)
L’API Cloud Billing Budget permet de gérer les budgets de coût définis par le client. Un budget correspond à un seuil financier (par ex. “alerte à 500€ de dépenses mensuelles”) avec éventuellement des filtres (par projet, par service GCP, etc.)[15]. Les budgets sont utiles en FinOps car ils déclenchent des alertes (email ou Pub/Sub) lorsque certains paliers sont atteints (50%, 90%, 100% du budget, etc.).
Dans notre contexte, on va surtout lire les budgets existants pour en extraire des informations de seuil et éventuellement les dépenses courantes par rapport aux budgets. Gardez à l’esprit que l’API Budget ne donne pas directement “la dépense actuelle” : elle stocke la configuration des budgets et les règles d’alertes, mais pas un compteur de dépenses à date accessible par simple requête (les notifications de dépense se font via Pub/Sub). Toutefois, on peut déduire certaines choses, comme le budget total alloué et les pourcentages de seuil.
	•	Lister les budgets : endpoint GET https://billingbudgets.googleapis.com/v1/billingAccounts/ID/budgets (où ID est l’identifiant du compte de facturation, même format que précédemment). Cela retourne un JSON comportant un champ budgets (tableau). Chaque élément a une structure assez complète, par ex. :
{  "name": "billingAccounts/012345-67890-ABCDEF/budgets/abcdefghijklmnopqrstuvwxyz",  "displayName": "Budget mensuel Projet X",  "budgetFilter": {    "projects": [ "projects/123456789012" ],    "services": [ "services/AA11-BB22-CC33" ],    "creditTypesTreatment": "INCLUDE_ALL_CREDITS",    "calendarPeriod": "MONTH"  },  "amount": {    "specifiedAmount": {      "currencyCode": "EUR",      "units": "500"    }  },  "thresholdRules": [    { "thresholdPercent": 0.5, "spendBasis": "CURRENT_SPEND" },    { "thresholdPercent": 1.0, "spendBasis": "CURRENT_SPEND" }  ],  "allUpdatesRule": { "pubsubTopic": "projects/myproj/topics/budget-alerts", "schemaVersion": "1.0" },  "etag": "abc123..."}
Dans cet exemple fictif, “Budget mensuel Projet X” est un budget appliqué au projet dont l’ID numérique est 123456789012 (vous pouvez trouver l’ID numérique d’un projet via Cloud Resource Manager ou dans l’URL console). Il concerne uniquement un service particulier (identifié par son code de service GCP), et il inclut tous les crédits. Il se remet à zéro chaque MONTH. Le montant est spécifié à 500 EUR. Deux règles de seuil sont définies : 50% et 100% de dépenses. On voit aussi que ce budget est configuré pour envoyer les alertes vers un topic Pub/Sub (allUpdatesRule).
Appel via fetch :
const res = await fetch(  `https://billingbudgets.googleapis.com/v1/billingAccounts/${billingAccountId}/budgets`,  {    headers: {      "Authorization": `Bearer ${accessToken}`,      "x-goog-user-project": "<ID-projet-integrateur>"    }  });const data = await res.json();data.budgets.forEach(budget => {  console.log(budget.displayName + " = " + JSON.stringify(budget.amount));});
Cet appel suppose que l’utilisateur a le rôle approprié (Viewer suffit pour lire ses budgets[16]).
	•	Interpréter les budgets : Dans chaque budget, le champ amount peut être de deux types : soit specifiedAmount avec une somme définie (comme 500 EUR ci-dessus), soit lastPeriodAmount pour un budget reconduit basé sur la dépense du mois précédent[17]. Les thresholdRules indiquent les pourcentages d’alerte. Par exemple, si un budget est de 500€ et qu’on a un threshold à 0.5 (50%), cela signifie qu’à 250€ dépensés, une alerte sera émise (email/PubSub). Toutefois, l’API ne fournit pas la dépense actuelle. Elle ne fait que stocker les pourcentages. C’est via les notifications ou via un export BigQuery qu’on peut savoir si un seuil a été atteint. Vous pouvez cependant utiliser l’API Budget pour vérifier la présence de ces seuils et les afficher dans votre UI (par ex. “Budget mensuel 500€ : alertes à 50% et 100%”).
	•	Alerte en temps réel via Pub/Sub : Si le client a configuré un topic Pub/Sub pour les alertes (comme dans l’exemple allUpdatesRule.pubsubTopic), votre application pourrait s’y abonner (avec un push subscription ou en pulling) pour recevoir les notifications de dépense en quasi temps réel. C’est plus complexe à mettre en place (il faut une endpoint web pour recevoir les push, etc.). Pour un guide débutant, on peut supposer qu’on va s’en tenir aux données disponibles via API et BigQuery.
	•	Créer/modifier un budget : ce n’est pas demandé dans la question, mais sachez que via l’API vous pouvez aussi créer des budgets (POST sur /budgets) ou les modifier. Cela nécessite des rôles plus élevés (Costs Manager par exemple). Si votre SaaS vise à aider le client à créer des budgets (FinOps préventif), c’est faisable. Mais dans un premier temps, concentrons-nous sur la lecture.
En résumé, l’API Budget va nous servir à lister les budgets du client et à afficher les seuils d’alerte définis. Par exemple, votre tableau de bord pourrait afficher : “Budget mensuel Projet X : 500€ (alertes à 50% et 100%)”, ou “Aucun budget défini pour le scope global” si le client n’en a pas.
2.2.3 Suivre l’empreinte carbone (GreenOps) des ressources GCP
La composante GreenOps consiste à mesurer l’empreinte carbone liée à l’utilisation du cloud. Google Cloud fournit un outil Carbon Footprint dans la console qui estime les émissions de CO₂ associées à la consommation des services GCP par un client. Cependant, il n’existe pas d’API REST publique dédiée à Carbon Footprint[2]. Pour accéder à ces données de manière programmatique, la solution actuelle est de passer par BigQuery.
Google permet en effet d’exporter automatiquement les données d’empreinte carbone vers BigQuery, via le BigQuery Data Transfer Service[11]. L’idée : chaque mois, les émissions (en kg de CO₂) par service, projet et région sont injectées dans une table BigQuery. Votre application pourra ensuite requêter cette table pour obtenir les KPI “carbone” souhaités.
Mise en place de l’export carbone : Vous pouvez guider le client pour le faire manuellement dans la console : il va dans Carbon Footprint > Export > Create export, choisit le projet et dataset BigQuery de destination, etc. (voir doc Google). Cela créera un transfert de données BigQuery planifié. Alternativement, vous (ou votre appli) pouvez le faire via l’API BigQuery Data Transfer. Concrètement, il faut appeler l’endpoint projects/<proj>/locations/<loc>/transferConfigs:create avec un payload contenant "dataSourceId": "61cede5a-0000-2440-ad42-883d24f8f7b8" (identifiant de la source Carbon Footprint), le ou les billingAccountIds à exporter, et le dataset de destination[18]. Une fois le transfert configuré, Google alimentera la table BigQuery carbon_footprint chaque mois pour chaque compte de facturation lié.
⚠️ Permissions : pour créer ce transfert via API, il faut que l’identité utilisée ait le rôle Carbon Footprint Viewer ou Billing Account Viewer sur le compte (pour accéder aux données carbone)[19], et des permissions BigQuery sur le projet de destination (BigQuery Data Editor, etc. pour créer le dataset). Comme on l’a vu en 1.2, Billing Account Viewer inclut billing.accounts.getCarbonInformation, ce qui est requis.
Schéma des données carbone : La table BigQuery exportée contient les champs clés suivants : le mois d’usage (usage_month), le ID du compte de facturation, l’ID du projet (project.id), le service (service.id et service.description pour le nom lisible), la région (location.region ou zone) et surtout le total des émissions CO₂ pour ce projet/service sur le mois (carbon_footprint_total_kgCO2e.market_based)[20][21]. Il existe aussi une mesure “location_based” (facteur d’émission moyen par région) mais pour simplifier on utilisera market_based qui correspond aux chiffres prenant en compte l’achat d’énergies renouvelables par Google. Toutes les émissions de Scope 1, 2 et 3 sont englobées dans ce total[22].
Exploiter les données carbone via BigQuery : Vous avez deux possibilités pour récupérer ces données dans Next.js :
	•	Soit utiliser l’API BigQuery REST pour lancer une requête SQL sur la table d’export.
	•	Soit utiliser un client BigQuery côté serveur (ex. la librairie @google-cloud/bigquery en Node.js) pour exécuter des requêtes de façon plus confortable.
Pour rester dans le thème “API REST”, décrivons la première méthode : l’API BigQuery propose un endpoint POST https://bigquery.googleapis.com/bigquery/v2/projects/<PROJECT>/queries qui permet de soumettre une requête SQL. On fournit dans le corps un JSON avec la requête, et éventuellement on peut spécifier l’identifiant de dataset par défaut.
Exemple de requête : Supposons que les données carbone du client sont exportées dans un dataset BigQuery finops_reports dans le projet client-gcp-project, table carbon_footprint. Pour obtenir, par exemple, les émissions du mois en cours par projet, on pourrait exécuter une requête SQL du style :
SELECT   project.id AS project_id,   SUM(carbon_footprint_total_kgCO2e.market_based) AS total_kgCO2FROM   `client-gcp-project.finops_reports.carbon_footprint`WHERE usage_month = DATE_TRUNC(CURRENT_DATE(), MONTH)GROUP BY project_idORDER BY total_kgCO2 DESC;
Cette requête va grouper les émissions par projet pour le mois courant. Vous obtiendrez une liste des projets avec leur émission en kgCO₂, triée du plus émetteur au moins émetteur.
Pour l’exécuter via l’API, vous enverriez :
const query = `SELECT project.id, SUM(carbon_footprint_total_kgCO2e.market_based) as total_co2               FROM \`client-gcp-project.finops_reports.carbon_footprint\`               WHERE usage_month = DATE_TRUNC(CURRENT_DATE(), MONTH)               GROUP BY project.id               ORDER BY total_co2 DESC               LIMIT 5`;const res = await fetch(  `https://bigquery.googleapis.com/bigquery/v2/projects/client-gcp-project/queries`,  {    method: "POST",    headers: {      "Authorization": `Bearer ${accessToken}`,      "Content-Type": "application/json"    },    body: JSON.stringify({ query: query })  });const result = await res.json();console.log(result.rows);
Si les permissions sont correctes, BigQuery va exécuter la requête et retourner un résultat (attention, ce résultat peut être en plusieurs pages si volumineux : on aurait alors un jobId à utiliser pour récupérer les pages suivantes via l’API). Mais dans notre cas de top 5, tout rentrera probablement dans une seule réponse. Le champ result.rows contient un tableau de lignes, chaque ligne ayant les valeurs des colonnes sélectionnées (souvent sous forme de chaînes). Il faudra mapper ces résultats pour obtenir par ex. un array d’objets { project: "my-project", total_co2: 123.45 }.
Astuce : Pour éviter de builder des requêtes SQL en dur, vous pouvez créer des vues BigQuery ou utiliser des requêtes paramétrées. Toutefois, pour un début, construire la requête en JS comme ci-dessus est acceptable – veillez juste à échapper correctement les identifiants si vous insérez des variables.
Pas d’API directe : Insistons sur le fait qu’il n’y a pas d’endpoint Google tout fait de type “GetCarbonFootprint(billingAccount)” en REST. Il faut toujours passer par l’export BigQuery pour le GreenOps sur GCP. Donc le cœur du travail GreenOps sera de requêter BigQuery. L’avantage, c’est que BigQuery peut aussi contenir les coûts détaillés (via l’export de facturation) – on pourrait donc utiliser une approche similaire pour les coûts (voir section 3 sur les limitations).
2.3 Exemples de requêtes REST en JavaScript (fetch/Axios) et format des réponses
Nous allons récapituler avec quelques snippets comment appeler les différentes APIs depuis votre code Next.js (côté serveur, par ex. dans getServerSideProps ou dans une API Route, afin de ne pas exposer le token dans le navigateur).
	•	Exemple 1 : Lister les projets avec fetch (Cloud Billing API)
const accessToken = "...";  // supposé valideconst billingAccountId = "012345-67890-ABCDEF";const url = `https://cloudbilling.googleapis.com/v1/billingAccounts/${billingAccountId}/projects`;const res = await fetch(url, {  headers: {    Authorization: `Bearer ${accessToken}`,    "x-goog-user-project": "<votre-projet-id>"  }});const data = await res.json();// data.projectBillingInfo sera un tableaudata.projectBillingInfo.forEach(info => {  console.log(`Projet ${info.projectId} -> billingEnabled=${info.billingEnabled}`);});
Réponse attendue : un objet comportant projectBillingInfo qui est une liste d’objets { name: "projects/<proj>/billingInfo", projectId: "<proj>", billingAccountName: "billingAccounts/...</billingAccountName>", billingEnabled: true/false }. Typiquement vous n’aurez besoin que de projectId et billingEnabled. Vous pourriez stocker la liste des projets du client en variable d’état ou la passer à votre page Next.js pour affichage.
	•	Exemple 2 : Lister les budgets avec Axios (Budget API)
import axios from 'axios';const listBudgets = async (billingAccountId) => {  const url = `https://billingbudgets.googleapis.com/v1/billingAccounts/${billingAccountId}/budgets`;  const response = await axios.get(url, {    headers: {      Authorization: `Bearer ${accessToken}`,      "x-goog-user-project": "<votre-projet-id>"    }  });  const budgets = response.data.budgets;  budgets.forEach(b => {    console.log(`${b.displayName}: montant=${JSON.stringify(b.amount)}`);  });  return budgets;};
Ici on utilise Axios pour la démonstration. La réponse (response.data) contiendra un champ budgets (tableau). Chaque élément a des sous-champs comme expliqué en 2.2.2. Vous pouvez accéder par ex. à b.displayName (nom du budget), b.budgetFilter.projects (liste des projets concernés par le budget, si filtré) ou b.thresholdRules (tableau des seuils d’alerte). Pour afficher un budget dans votre dashboard, vous pourriez montrer : Nom, Montant du budget (ex. 500€), Période (mensuelle, trimestrielle...), et Seuils (50%, 100%). Ces infos sont toutes dans l’objet JSON du budget. Par exemple, b.amount.specifiedAmount.units vous donne le montant en unité monétaire (euros dans l’exemple, il y a aussi currencyCode), ou si c’est lastPeriodAmount cela signifie “budget égal aux dépenses du dernier mois”[17].
	•	Exemple 3 : Requête BigQuery via REST (coûts mensuels)
Supposons que le client a également exporté ses coûts détaillés vers BigQuery (option Billing Export activée sur le compte de facturation, écrivant dans un dataset p. ex. billing_data). Ces tables de coûts ont un schéma différent (beaucoup de colonnes : projet, service, SKU, coût, etc. par jour). Une requête type pour le coût total du mois en cours pourrait être :
SELECT SUM(cost) as total_costFROM `client-gcp-project.billing_data.gcp_billing_export_v1_<ID>` WHERE EXTRACT(MONTH FROM usage_start_time) = EXTRACT(MONTH FROM CURRENT_TIMESTAMP())  AND EXTRACT(YEAR FROM usage_start_time) = EXTRACT(YEAR FROM CURRENT_TIMESTAMP());
(Remplacez le nom de table par celui configuré chez le client, qui inclut souvent l’ID du compte de facturation). Cette requête somme les coûts du mois courant. Appelée via l’API BigQuery, elle renverra une ligne avec le total. Vous pouvez alors l’afficher, par ex. “Coût du mois en cours : 1234.56 €”.
Dans Next.js, vous pouvez appeler l’API BigQuery de manière similaire au fetch vu dans 2.2.3. Veillez à bien utiliser le project du client dans l’URL (.../projects/client-gcp-project/queries) et à disposer des droits BigQuery (le token doit avoir scope BigQuery et l’utilisateur doit avoir accès au dataset).
Chaque appel d’API REST doit inclure le header Authorization: Bearer <token> fourni par OAuth. Si le token a expiré, rafraîchissez-le avant de retenter la requête.
Au niveau du format JSON des réponses, n’hésitez pas à tester ces endpoints avec un outil comme curl ou Postman en utilisant un token obtenu via l’OAuth 2.0 Playground de Google, par exemple, pour voir les structures exactes. La documentation officielle Google fournit aussi des exemples de réponses pour chaque méthode (cf. liens de référence).
2.4 Construction de tableaux de bord Next.js simples
Avec les données brutes récupérées via les APIs, vous pouvez maintenant construire des tableaux de bord FinOps/GreenOps dans votre application Next.js. Pour un développeur débutant, voici quelques conseils d’implémentation front-end :
	•	Récupération des données côté serveur : Il est souvent plus simple (et sécurisé) d’appeler les APIs Google depuis le côté serveur de votre appli Next.js, puis de passer les résultats aux composants React. Vous pouvez utiliser getServerSideProps (si la page doit toujours être à jour côté serveur) ou getStaticProps + revalidation (si les données peuvent être mises en cache quelques minutes). Par exemple, votre page Dashboard pourrait utiliser getServerSideProps(context) pour, à chaque chargement, appeler les fonctions décrites plus haut (listProjects, listBudgets, requête BigQuery…) en utilisant le token stocké (peut-être dans un cookie de session ou en base). Le résultat (par ex. liste des projets avec coûts, etc.) serait renvoyé dans les props de la page.
	•	Agrégation des données : Avant de passer aux composants d’affichage, agrégrez/traitez un peu les données :
	•	Calculez le coût total du mois en cours en additionnant soit les coûts par projet (si vous les avez via BigQuery) soit en utilisant la requête BigQuery dédiée mentionnée plus haut. C’est un KPI FinOps de base.
	•	Identifiez le Top 5 des projets les plus coûteux : si vous avez les données BigQuery par projet (comme l’exemple de requête top 5), vous avez déjà cette liste. Sinon, vous pourriez sommer les coûts par projet vous-même côté Node si vous avez une liste détaillée.
	•	Récupérez le CO₂ mensuel total : via une requête BigQuery similaire à celle des coûts, mais sur la table carbone (somme de carbon_footprint_total_kgCO2e pour le mois). Vous pourriez aussi calculer un équivalent, par ex. “X kg CO₂, soit Y km en voiture” pour parler au client, mais cela sort du scope technique.
	•	D’autres KPI possibles : coût par service (Top services coûteux), tendance d’évolution (nécessite de comparer plusieurs mois, donc plusieurs requêtes ou une requête SQL plus élaborée utilisant GROUP BY sur MONTH). Pour un guide débutant, commencez simple (valeurs du mois courant).
	•	Affichage dans Next.js : Utilisez des composants React pour présenter ces KPI. Par exemple, un composant <KpiCard title="Coût Mensuel" value={totalCost}/> pour afficher le coût total. Une liste ou un tableau pour le top 5 projets : vous pouvez utiliser un simple <ul>:
<h3>Top 5 Projets (Coût mensuel)</h3><ul>  {topProjects.map(proj => (    <li key={proj.id}>      {proj.name} – {proj.cost.toFixed(2)} €    </li>  ))}</ul>
Ici topProjects serait un array d’objets {id, name, cost}. Vous pouvez récupérer le name du projet via un appel Resource Manager si l’ID n’est pas parlant, mais ce n’est pas obligatoire.
Pour l’empreinte carbone : de même, affichez soit le total, soit le top 5 projets en fonction de l’émission. Par exemple :
<h3>Émissions CO₂ du mois (kg)</h3><p>Total : {totalCO2.toFixed(1)} kg CO₂e</p><ul>  {topProjectsByCO2.map(proj => (    <li key={proj.id}>      {proj.name} – {proj.co2.toFixed(1)} kg CO₂e    </li>  ))}</ul>
	•	Utiliser une bibliothèque de graphiques (en bonus) : Pour rendre le dashboard plus visuel, vous pouvez utiliser des libs comme Chart.js ou Recharts. Par exemple, un pie chart des coûts par projet, ou une barre montrant l’évolution du coût mois par mois (il faudra alors obtenir plusieurs mois de données via BigQuery). Comme c’est un guide pédagogique, vous pouvez noter cette possibilité mais ce n’est pas obligatoire pour la fonctionnalité. Même avec juste du texte et des listes, l’utilisateur aura l’information essentielle.
	•	Actualisation des données : Les coûts et émissions évoluent constamment. Vous pourriez mettre en place un rafraîchissement automatique (par ex. revalidation ISR toutes les heures, ou bouton “Rafraîchir”). Faites attention aux quotas d’API si vous rafraîchissez trop fréquemment. Un appel par heure et par client pour chaque API est largement acceptable. Si vous avez un grand nombre de clients, envisagez de mettre en file d’attente ou de consolider certaines requêtes (par ex. batcher plusieurs requêtes BigQuery en une seule plus grosse requête multi-clients, si vous avez les droits – mais en général chaque client n’autorisera que son propre compte, donc ce sera isolé).
En synthèse, du côté intégrateur Next.js, on authentifie l’utilisateur, on récupère les données via REST, on pré-calcul quelques indicateurs, et on affiche dans une interface claire. Avec Next.js, profitez du rendu côté serveur pour sécuriser les appels aux APIs Google (pas d’exposition du token au client), et passez seulement les résultats nécessaires au navigateur.
3. Limitations des APIs REST vs export BigQuery (FinOps & GreenOps)
Il est important de connaître les limites des APIs REST Google Cloud par rapport aux données disponibles via les exports BigQuery, afin de concevoir la solution la plus complète :
	•	Pas d’API de coût cumulatif direct : Google Cloud ne propose pas d’API REST donnant “le montant dépensé ce mois-ci” ou “le coût par service”. La Cloud Billing API permet de gérer la facturation (comptes, rattachement de projets) mais pas d’obtenir le détail des dépenses. Comme le confirme Google : “il n’existe pas d’API pour voir le coût d’un projet” en temps réel[12]. La seule manière d’avoir des données de coût détaillées est d’utiliser l’export de facturation vers BigQuery. Ce dernier fournit des données granulaires par ressource (SKU, libellé, projet, service, jour...). C’est bien plus précis que le tableau de bord en ligne. Par exemple, via BigQuery on peut trouver quel VM ou quel job BigQuery a coûté le plus cher, ce qui est impossible via l’interface web standard sans export[23]. En résumé, BigQuery est indispensable pour une analyse FinOps fine (anomalies de coûts, répartition par tags, etc.).
	•	Budgets API limitée : L’API Budget ne donne pas la consommation en temps réel. Elle est faite pour gérer les seuils. Pour connaître la consommation actuelle par rapport au budget, Google envoie des notifications (email ou Pub/Sub) quand un seuil est franchi. Il n’y a pas de champ “amountSpent” dans la ressource Budget accessible via GET qui vous indiquerait par exemple “400€ dépensés sur 500€”. Il faut soit calculer manuellement la dépense (via BigQuery) soit recevoir les alertes. Donc pour votre appli, si le besoin est de montrer “X% du budget utilisé”, vous devrez calculer X% = (dépense du mois / montant budget) × 100, en obtenant dépense du mois via BigQuery. L’API Budget ne suffira pas.
	•	Données en temps différé : Les exports BigQuery ne sont pas temps réel à la minute. Le Billing Export vers BigQuery a généralement quelques heures de délai (les coûts du jour apparaissent parfois le lendemain, ou avec 1 jour de latence, selon la configuration). L’export Carbon Footprint est mensuel (latence jusqu’à mi-mois suivant). Donc votre appli affichera des données à jour d’hier pour les coûts, et à jour du mois dernier pour le carbone. C’est normal dans le domaine FinOps/GreenOps (on analyse souvent les coûts du mois passé). Si le client veut du temps réel quotidien pour les coûts, il peut configurer le « Billing Data Transfer (Alpha) » qui sort peut-être en 2025+ (mais pour l’instant, BigQuery export est la voie). Il faut communiquer clairement ces délais.
	•	Multi-cloud / Multi-comptes : Si un client a plusieurs comptes de facturation, vos appels API devront gérer cela (ex : plusieurs entries dans billingAccounts). Il n’y a pas d’endpoint qui consolide plusieurs comptes en un. Idem, si un client voulait agréger des coûts GCP + AWS, ce serait à votre appli de faire la fusion des données (chaque cloud ayant ses APIs). BigQuery export pourrait servir de base pour importer d’autres sources aussi.
	•	Coûts vs engagements : L’API Cloud Billing ne donne pas d’info sur les engagements (Committed Use Discounts) ou recommandations d’optimisation, etc., bien que le rôle Viewer donne accès aux recommandations dans la console. Google a des APIs de recommender pour certaines optimisations (VM idle, etc.), mais pas directement intégrées dans Cloud Billing API v1. Donc en l’état, votre appli se concentrera sur les coûts réels et l’empreinte carbone, et non sur les recommandations d’optimisation (ce serait un plus mais hors scope pour débuter).
	•	Vérification et test : Sans BigQuery export, tester la récupération de coûts est difficile. Donc assurez-vous en phase de test d’avoir accès à un projet GCP de test avec un compte de facturation et un export BigQuery activé. Sinon, l’API Cloud Billing seule vous laissera un peu “aveugle” sur les montants.
En bref, les APIs Cloud Billing/Budget fournissent la structure (comptes, projets, budgets), mais pour les données chiffrées de coûts et carbone, il faut exploiter les exports BigQuery. Cette contrainte influence fortement l’architecture : par exemple, prévoir dans votre SaaS une étape où le client renseigne le dataset BigQuery où sont ses données de coûts/carbone, ou bien utiliser le token du client pour interroger directement le dataset dont vous connaissez l’emplacement s’il suit un convention standard.
4. Checklist de tests (du bon fonctionnement)
Avant de déployer votre solution, passez en revue cette checklist pour vous assurer que tout fonctionne de bout en bout :
	•	[ ] OAuth2 configuré et fonctionnel : Vous avez créé le client OAuth sur Google Cloud, ajouté les URI de redirection, et testé le flow depuis votre appli Next.js. Le client peut se connecter avec son compte Google et vous obtenez un access_token valable avec les scopes requis (cloud-billing, billingbudgets, bigquery, etc.). Vérifiez que le token contient bien ces scopes (décodable sur jwt.io ou via l’endpoint tokeninfo).
	•	[ ] APIs Google activées : Vérifiez dans la Google Cloud Console de votre projet intégrateur que Cloud Billing API, Cloud Billing Budget API, BigQuery API et BigQuery Data Transfer API sont activées (au moins celles dont vous aurez besoin directement). Sans cela, vous pourriez obtenir des erreurs 403 ou 404 sur les endpoints.
	•	[ ] Rôles IAM corrects côté client : Connectez-vous avec un compte ayant le rôle Billing Account Viewer sur le compte de facturation du client et Viewer sur un projet. Testez un appel à billingAccounts – il doit retourner le compte du client. Si vous obtenez une liste vide alors que le compte existe, c’est un problème de permissions. Testez l’appel billingAccounts/ID/projects – il doit lister les projets. Si vide alors qu’il y a des projets liés, c’est possiblement un manque de permission sur la liste des associations (vérifier billing.resourceAssociations.list).
	•	[ ] Projet GCP lié à facturation : Faites un test sur un projet dont la facturation est désactivée, il devrait apparaître avec billingEnabled=false dans les résultats. Activez la facturation, relancez l’appel, il passe à true. Cela confirme que votre logique détecte correctement l’état.
	•	[ ] Données de budget récupérées : Si le client a défini des budgets, vos appels à l’API Budget (listBudgets) doivent renvoyer ces budgets. Vérifiez que vous pouvez bien lire les displayName et amount. Si pas de budget, envisagez ce cas (afficher “Aucun budget configuré” dans le dashboard par exemple).
	•	[ ] Export BigQuery de facturation en place (le cas échéant) : Dans le BigQuery du client, assurez-vous qu’il y a une table d’export des coûts (si le client l’a activé). Si oui, exécutez une requête de test manuellement (via l’UI BigQuery ou gcloud) pour voir des données. Par exemple, SELECT SUM(cost) FROM table WHERE DATE = hier. Cela pour vérifier qu’il y a bien des données chiffrées.
	•	[ ] Export BigQuery de Carbon Footprint en place : Vérifiez de même la présence de la table carbon_footprint dans le dataset cible. Assurez-vous qu’elle contient au moins les données du mois précédent (si configuré il y a plus de 15 jours). Sinon, initiez un backfill via la console (Carbon Footprint > Export > Export historical data) ou via l’API Transfer (startManualRuns avec date de début en 2021)[24][25].
	•	[ ] Appel BigQuery API : Testez votre fonction de requête BigQuery via REST ou client. Par exemple, appelez la requête de somme des coûts du mois. Vérifiez que la réponse renvoie un total cohérent (comparez-le éventuellement avec le tableau de bord de facturation dans la console GCP pour le même compte/projet sur le même intervalle). Ajustez la requête si nécessaire (par ex. exclure les crédits si besoin, etc.).
	•	[ ] Tableau de bord Next.js affiché correctement : Démarrez votre appli en local, connectez-vous avec un compte de test, et affichez la page dashboard. Vous devriez voir apparaître les KPI : coût total du mois, liste des projets avec leurs coûts (ou les top N), émissions carbone total du mois, etc., en fonction de ce que vous avez implémenté. Vérifiez le format (devise € correctement affichée, nombres arrondis convenablement, etc.).
	•	[ ] Comportement sans données : Testez le cas où un client n’a pas configuré l’export BigQuery. Votre appli devrait détecter l’absence de données et par exemple afficher un message du style “Export BigQuery non configuré – impossible de récupérer les coûts détaillés” plutôt que planter. Idem pour l’empreinte carbone. Un développeur débutant peut prévoir des gardes-fous : ex. si la requête BigQuery renvoie une erreur, catch l’erreur et afficher une alerte sur le dashboard.
	•	[ ] Sécurité des données : Assurez-vous que vous ne logguez pas d’informations sensibles (par ex. ne pas console.log tout le JSON de budgets en prod, ce qui pourrait finir dans vos logs). Ne stockez pas non plus les tokens d’accès en clair côté client. Utilisez les API routes Next.js pour toute action nécessitant le token, de sorte que le navigateur n’ait que les données finales. Vérifiez aussi que chaque client n’accède qu’à ses propres données (multi-tenancy) : par exemple, si vous stockez en session l’identifiant du compte de facturation autorisé, utilisez-le explicitement et ne mélangez pas avec un autre client.
Une fois tous ces points vérifiés, vous devriez avoir une application SaaS Next.js pleinement fonctionnelle, permettant à un utilisateur débutant sur Google Cloud de visualiser ses coûts cloud (FinOps) par projet/service/région et son empreinte carbone (GreenOps) associée, le tout via des appels API sécurisés et avec un tableau de bord pédagogique 🎉.
Sources : Pour aller plus loin, la documentation Google Cloud associée aux sujets abordés est disponible (en anglais et français) et a été utilisée pour ce guide : activation des APIs et rôles IAM[4][3], utilisation de Cloud Billing API/Budget API[12][26], export Carbon Footprint via BigQuery[2][11], schéma des données d’empreinte carbone[20][21], etc. N’hésitez pas à vous y référer pour plus de détails. Bon développement !

[1] [13] [14] Method: billingAccounts.projects.list  |  Cloud Billing  |  Google Cloud
https://cloud.google.com/billing/docs/reference/rest/v1/billingAccounts.projects/list
[2] [10] [18] [24] [25] Export and read your carbon footprint using an API  |  Carbon Footprint Documentation  |  Google Cloud
https://cloud.google.com/carbon-footprint/docs/api
[3] [4] [5] [6] [7] [8] [9] [16] Access control for Cloud Billing APIs  |  Google Cloud
https://cloud.google.com/billing/docs/access-control
[11] [19] Export your carbon footprint  |  Carbon Footprint Documentation  |  Google Cloud
https://cloud.google.com/carbon-footprint/docs/export
[12] google cloud platform - What API can I use to see my GCP bill amount? - Stack Overflow
https://stackoverflow.com/questions/66080224/what-api-can-i-use-to-see-my-gcp-bill-amount
[15] [17] [26] Using the Cloud Billing Budget API  |  Google Cloud
https://cloud.google.com/billing/docs/how-to/budget-api
[20] [21] [22] Carbon Footprint export data schema  |  Carbon Footprint Documentation  |  Google Cloud
https://cloud.google.com/carbon-footprint/docs/data-schema
[23] Why do companies use billing exports to BigQuery? : r/googlecloud
https://www.reddit.com/r/googlecloud/comments/1cozj48/why_do_companies_use_billing_exports_to_bigquery/

---
description:
globs:
alwaysApply: true
---
